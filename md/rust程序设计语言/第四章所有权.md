# 所有权

## 堆与栈

在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。

栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 **后进先出**（*last in, first out*）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 **进栈**（*pushing onto the stack*），而移出数据叫做 **出栈**（*popping off the stack*）。栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 **指针**（*pointer*）。这个过程称作 **在堆上分配内存**（*allocating on the heap*），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。

入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。

当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。

跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

## 规则

1. Rust 中的每一个值都有一个 **所有者**（*owner*）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

等效于

- 当 `s` **进入作用域** 时，它就是有效的。
- 这一直持续到它 **离开作用域** 为止。

## String

```rust
fn main() {
    // 分配到堆  String 类型，为了支持一个可变，可增长的文本片段，
    let mut s = String::from("hello world");
    // 下列代码会报错,rust 在处理堆上的变量时,并不会拷贝,也不会让两个指针指向同一块内存
    // 因为会导致内存二次释放的安全性bug,  所以在借用后,s变量就不能再访问
    // 其他语言中成为浅拷贝,深拷贝  rust中称为移动
    // let s2 = s;

    // 若需要深拷贝 可以使用clone,堆上的信息被复制了
    let s2 = s.clone();

    // 栈上的数据会被直接拷贝
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
    println!("{s}");
    // 追加字符串
    s.push_str("!");
    println!("{}", s);
    println!("s2 is {}", s2);
} // 离开作用域后自动调用drop函数,回收内存
```

### 可拷贝的类型

任何不需要分配内存或某种形式资源的类型都可以实现 `Copy` 。如下是一些 `Copy` 的类型：

- 所有整数类型，比如 `u32`。
- 布尔类型，`bool`，它的值是 `true` 和 `false`。
- 所有浮点数类型，比如 `f64`。
- 字符类型，`char`。
- 元组，当且仅当其包含的类型也都实现 `Copy` 的时候。比如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 就没有。

### 所有权与函数

```rust
fn main() {
    let name = String::from("zhang fei ");
    // name 进入作用域
    say_hello(name);
    // 离开作用域 name失效
    let x = 3;
    say_num(x);
    // x仍然能使用
    println!("{}", x);
}

fn say_hello(name: String) {
    // 进入作用域
    println!("hello {}!", name);
    // 释放name
}

fn say_num(num: i32) {
    // 可copy 所以没有什么特殊之处
    println!("num is {}!", num);
}
```

### 返回值与作用域

```rust
fn main() {
    // 所有权转义给s
    let s = give_ownership();
    let s2 = String::from("hello");
    // s2被移动到函数中,并返回
    let s3 = takes_and_give_back(s2);
}

fn give_ownership() -> String {
    String::from("hello")
}

fn takes_and_give_back(s: String) -> String {
    // 使用值,并返回
    s
}
```

### 转移返回值的所有权

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串的长度
    (s, length)
}
```

## 引用与借用

