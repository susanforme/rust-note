# 集合

常用集合

- *vector* 允许我们一个挨着一个地储存一系列数量可变的值
- **字符串**（*string*）是字符的集合。我们之前见过 `String` 类型，不过在本章我们将深入了解。
- **哈希 map**（*hash map*）允许我们将值与一个特定的键（key）相关联。这是一个叫做 *map* 的更通用的数据结构的特定实现。

## vector

文档 https://doc.rust-lang.org/std/vec/struct.Vec.html

```rust
fn main() {
    // 创建空的vector
    let mut v: Vec<i32> = Vec::new();
    // 使用vec!宏 创建信的vector
    let mut other_v = vec![1, 2, 3];
    // 添加元素
    v.push(5);
    other_v.push(4);
    // 读取vector 得到索引元素位置的引用
    let third: &i32 = &v[0];
    println!("The third element is {third}");

    // 返回的是一个Option 使用get访问
    let four = other_v.get(3);
    match four {
        Some(value) => {
            println!("value is {value} !");
        }
        None => {
            println!("there is not four element!");
        }
    }
    // 遍历元素 获取不可变引用并打印
    for i in &v {
        println!("i is {i}");
    }
    // 可变引用并修改
    for i in &mut other_v {
        // 解引用获取值
        *i += 50;
    }
}

```

### 在拥有vector的引用时同时向其增加一个元素

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];
    // 编译错误
    v.push(6);

    println!("The first element is: {first}");
}
```

为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。

### 使用枚举来存储多类型

```rust
enum SpreadSheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
fn main() {
    // 存储不同类型
    let row = vec![
        SpreadSheetCell::Int(32),
        SpreadSheetCell::Float(32.3),
        SpreadSheetCell::Text(String::from("value")),
    ];
}

```

## 离开作用域释放所有元素

```rust
fn main() {
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
}
```

## 字符串

```rust
fn main() {
    // 新建字符串
    let mut s = String::from("hello");
    // l新建空的string 可用于字符串字面值
    let data = "initial contents";
    let s1 = data.to_string();
    // 附加字符串slice
    s.push_str(" world");
    // 单独字符作为参数
    s.push('!');
    println!("{s}");
}

```

使用+运算符将两个String合并到新的String

```rust
fn main(){
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    // 注意 s1 被移动了，不能继续使用
    let s3 = s1 + &s2;
    // 编译失败
    // s1.push('c');
    println!("s3 is {}!", s3);
}
```

执行完这些代码之后，字符串 `s3` 将会包含 `Hello, world!`。`s1` 在相加后不再有效的原因，和使用 `s2` 的引用的原因，与使用 `+` 运算符时调用的函数签名有关。`+` 运算符使用了 `add` 函数，这个函数签名看起来像这样：

```rust
fn add(self, s: &str) -> String 
```

`s2` 使用了 `&`，意味着我们使用第二个字符串的 **引用** 与第一个字符串相加。这是因为 `add` 函数的 `s` 参数：只能将 `&str` 和 `String` 相加，不能将两个 `String` 值相加。不过等一下 —— 正如 `add` 的第二个参数所指定的，`&s2` 的类型是 `&String` 而不是 `&str`。那么为什么示例 8-18 还能编译呢？

之所以能够在 `add` 调用中使用 `&s2` 是因为 `&String` 可以被 **强转**（*coerced*）成 `&str`。当`add`函数被调用时，Rust 使用了一个被称为 **Deref 强制转换**（*deref coercion*）的技术，你可以将其理解为它把 `&s2` 变成了 `&s2[..]`。第十五章会更深入的讨论 Deref 强制转换。因为 `add` 没有获取参数的所有权，所以 `s2` 在这个操作后仍然是有效的 `String`。

发现签名中 `add` 获取了 `self` 的所有权，因为 `self` **没有** 使用 `&`。这意味着示例 8-18 中的 `s1` 的所有权将被移动到 `add` 调用中，之后就不再有效。

实际上这个语句会获取 `s1` 的所有权，附加上从 `s2` 中拷贝的内容，并返回结果的所有权

### 复杂字符串连接使用format宏

```rust
fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
    // 编译失败,所有权被移动
    // s3.push('1');
}
```

### 索引字符串

rust中不支持通过索引访问String的一部分

`String` 是一个 `Vec<u8>` 的封装。

```rust
fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
}
```

 Rust 不允许使用索引获取 `String` 字符的原因是，索引操作预期总是需要常数时间（O(1)）。但是对于 `String` 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。

### 字符串slice

```rust
fn main() {
    let s1 = String::from("tic");
    let s = &s1[0..2];
    for c in s.chars() {
        println!("{c}");
    }
}
```

&hello[0..1] 会panic

# Hash Map

和vector一样存储在堆

