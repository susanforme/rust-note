# 枚举

`IpAddr::V4()` 是一个获取 `String` 参数并返回 `IpAddr` 类型实例的函数调用。作为定义枚举的结果，这些构造函数会自动被定义。

```rust
enum IpAddrKind {
    v4,
    v6,
}
enum IpAddr {
    v4(String),
    v6(String),
}

struct Ip {
    kind: IpAddrKind,
    address: String,
}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl Message {
    fn call(&self) {
        println!("call!",);
    }
}

fn main() {
    let four = IpAddrKind::v4;
    let six = IpAddrKind::v6;
    let home = Ip {
        kind: IpAddrKind::v4,
        address: String::from("192.168.1.1"),
    };
    // 和上方含义相同
    let home2 = IpAddr::v4(String::from("127.0.0.1"));
    let m = Message::Write(String::from("message"));
    m.call();
}

```

## [`Option` 枚举和其相对于空值的优势](https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html#option-枚举和其相对于空值的优势)

```rust
// 存在标准库中
enum Option<T> {
    None,
    Some(T),
}
```

```rust
fn main() {
    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = None;
}
```

当有一个 `Some` 值时，我们就知道存在一个值，而这个值保存在 `Some` 中。当有个 `None` 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，`Option<T>` 为什么就比空值要好呢？

简而言之，因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 `Option<T>`。例如，这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加：

```rust
  let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```

